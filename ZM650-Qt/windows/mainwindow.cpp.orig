/*
 * mainwindow.cpp
 *
 * 主界面
 *
 * Created on: 2019年 01月 21日 星期一 15:00:15 CST
 * Author: lixingcong
 */
#include "mainwindow.h"
#include "data/utils.h"
#include "platform/common.h"
#include "data/globaldata.h"
#include "data/adapters.h"
#include "ui_mainwindow.h"
#include "windows/subwindowrunstatus.h"
#include "windows/subwindowteachtable.h"
#include "windows/subwindowparams.h"
#include "windows/subwindowdiagnose.h"
#include "windows/subwindowtrail.h"
#include "windows/subwindowpatterns.h"
#include "windows/subwindowfilemanage.h"
#include <QLabel>
#include "modbus/modbusaddress.h"
#include <tr1/functional>
#include <ManualMotion.h>
#include <SysKey.h>
#include "widgets/qpushbuttonlongpress.h"
#include "widgets/qdialogloadingworkfile.h"
#include "data/uistyles.h"
#include <QObject>
#include <QTimer>
#include <QDateTime>


Q_DECLARE_METATYPE(MainWindow::ModbusQueryItemType)

const QStringList MainWindow::TAB_BUTTON_NAMES =
{
//    QString::fromUtf8("系统"),
//    QString::fromUtf8("教导"),
//    QString::fromUtf8("参数"),
//    QString::fromUtf8("文件"),
//    QString::fromUtf8("诊断"),

//        QT_TR_NOOP_UTF8("系统"),
//        QT_TR_NOOP("教导"),
//        QT_TR_NOOP("参数"),
//        QT_TR_NOOP("文件"),
//        QT_TR_NOOP("诊断"),
    QObject::trUtf8("系统"),
    QObject::trUtf8("教导"),
    QObject::trUtf8("参数"),
    QObject::trUtf8("文件"),
    QObject::trUtf8("诊断"),
//    QObject::trUtf8("急救"),//测试程序
<<<<<<< HEAD

=======
>>>>>>> cj
};

MainWindow::MainWindow(QWidget* parent) : QWidget(parent),
    ui(new Ui::MainWindow),
    labelCurrentTabHint(new QLabel(this)),
    lastSubWindow(nullptr),
    workerThread(new QThreadMainWindow(this)),
<<<<<<< HEAD
    modbusPendingCount(0),
    heartBeatCounter(0)
=======

    heartBeatCounter(0),
    modbusPendingCount(0)
>>>>>>> cj
{
    ui->setupUi(this);

    Utils::setFullScreen(this);
    GlobalData::pushButtonPage = ui->buttons;
    GlobalData::labelTopTab = ui->tabText;

    // Create the tabs
    ui->tabs->init(TAB_BUTTON_NAMES);
    connect(ui->tabs, SIGNAL(tabClicked(int)),
            this, SLOT(onTabIndexChanged(int)));

    ui->buttons->initLayout(5);

    //显示系统时间
    //新建定时器
    QTimer *timer = new QTimer(this);
    //关联定时器计满信号和相应的槽函数
    connect(timer,SIGNAL(timeout()),this,SLOT(timerUpDate()));
    //定时器开始计时，其中1000表示1000ms即1秒
    timer->start(1000);

    // load MainFrame
    //    auto subWindow=new SubWindowRunStatus(this);
    //    ui->layout_SubWindow->addWidget(subWindow);

    // systemAlarm
    QList<QLabelSystemAlarm::BlinkStyleType> alarmMsgStyle =
    {
<<<<<<< HEAD
        {false, UIStyles::CSS_ALARMMSG_LEVEL_1, QString()},
        {true,  UIStyles::CSS_ALARMMSG_LEVEL_2_1, UIStyles::CSS_ALARMMSG_LEVEL_2_2},
        {true,  UIStyles::CSS_ALARMMSG_LEVEL_3_1, UIStyles::CSS_ALARMMSG_LEVEL_3_2},
=======
        {false, UIStyles::CSS_ALARMMSG_LEVEL_1, QString()},//正常
        {true,  UIStyles::CSS_ALARMMSG_LEVEL_2_1, UIStyles::CSS_ALARMMSG_LEVEL_2_2},//黄色
        {true,  UIStyles::CSS_ALARMMSG_LEVEL_3_1, UIStyles::CSS_ALARMMSG_LEVEL_3_2},//红色
>>>>>>> cj
    };
    ui->alarmMessage->init(alarmMsgStyle);
    connect(ui->alarmMessage, SIGNAL(clicked()),
            this, SLOT(onButtonClicked_ResetAlarm()));

    // modbus callback
    connect(this, SIGNAL(_signal_modbusQueryCallback(bool, void*)),
            this, SLOT(onModbusQueryCallbackEnd(bool, void*)), Qt::QueuedConnection);
    connect(this, SIGNAL(sendModbusQuery(MainWindow::ModbusQueryItemType*, int)),
            this, SLOT(onSendModbusQuery(MainWindow::ModbusQueryItemType*, int)));

    // worker thread
    connect(workerThread, SIGNAL(sendModbusQuery(MainWindow::ModbusQueryItemType*, int)),
            this, SLOT(onSendModbusQuery(MainWindow::ModbusQueryItemType*, int)), Qt::QueuedConnection);
    connect(this, SIGNAL(_signal_notifyWorkerQueryDone(int)),
            workerThread, SLOT(queryDone(int)), Qt::QueuedConnection);

    // update real time
    connect(this, SIGNAL(_updateRealtimeInfo()),
            this, SLOT(onUpdateRealtimeInfo()));

    // bottom buttons
    connect(GlobalData::pushButtonPage, SIGNAL(buttonClicked(int)),
            this, SLOT(_onClickedBottomButton(int)));

    // global signals
    connect(this, SIGNAL(_updateRealtimeInfo()),
            GlobalData::getInstance(), SLOT(_updateRealtimeInfo()));
}

void MainWindow::timerUpDate()
{

#ifdef _MCGS
QDateTime time = platform_sys_info_c::get_rtc_time();
#else
QDateTime time = QDateTime::currentDateTime();
#endif
//获取系统现在的时间
//QString str = time.toString("yyyy-MM-dd hh:mm:ss dddd");
QString str = time.toString("yyyy-MM-dd hh:mm:ss");
//设置系统时间显示格式
ui->label_datetime_main->setText(str);
//在标签上显示时间
}


MainWindow::~MainWindow()
{
    workerThread->setQuitFlag(true);
    Utils::waitForThreadFinished(workerThread);
    Utils::waitForPendingModbus(&modbusPendingCount);

    auto workfile = Workfile::getInstance();
    Utils::delete_pointer(workfile);

    delete ui;
}

bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
     if(event->type()==QEvent::MouseButtonPress)
     {
         qDebug("MainWindow::eventFilter mousePressEvent");
         if(ATPARA.TouchBeep)
         {
        #ifdef _MCGS
                int nRet = hal_set_bee_time(30);
                if(0 != nRet)
                {
                    qDebug( "beep failed: %d!", nRet);
                }
        #endif
         }
     }
     return QWidget::eventFilter(obj, event);
}

 void MainWindow::mousePressEvent(QMouseEvent *e)
 {
     if(e->type()==QEvent::MouseButtonPress)
     {
         //qDebug()<<"MainWindow QEvent::MouseButtonPress";
     }

     QWidget::mousePressEvent(e);
 }

void MainWindow::onTabIndexChanged(int tabIndex)
{
    QWidget* subWindow = nullptr;

    switch(tabIndex)
    {
    case 0:
    {
        auto window = new SubWindowRunStatus(this);
        subWindow = window;
        ui->tabText->setText(QObject::tr(TAB_BUTTON_NAMES.at(tabIndex).toUtf8()));
        ui->tabText->setMinimumWidth(100);
        ui->tabText->setStyleSheet(UIStyles::css_maincolorconf_u7);
        //告诉下位机当前界面
        writeInterface(SHOW_SYSTEM);
        break;
    }

    case 1:
    {
        auto window = new SubWindowTeachTable(this);
        connect(window, SIGNAL(moveAxis(int, int, int, double)),
                this, SLOT(onMoveAxis(int, int, int, double)));
        connect(this, SIGNAL(pointIndexChanged(int)),
                window, SLOT(onPointIndexChanged(int)));
        connect(this, SIGNAL(totalPointChanged(int)),
                window, SLOT(onTotalPointChanged(int)));
        subWindow = window;
        //ui->tabText->setText(TAB_BUTTON_NAMES.at(tabIndex));
        ui->tabText->setText(QObject::tr(TAB_BUTTON_NAMES.at(tabIndex).toUtf8()));
        writeInterface(SHOW_TEACH);
        break;
    }

    case 2:
    {
        auto window = new SubWindowParams(this);
        subWindow = window;
        //ui->tabText->setText(TAB_BUTTON_NAMES.at(tabIndex));
        ui->tabText->setText(QObject::tr(TAB_BUTTON_NAMES.at(tabIndex).toUtf8()));
        writeInterface(SHOW_PARA);
        break;
    }

    case 3:
    {
        auto window = new SubWindowFileManage(this);
        subWindow = window;
        //ui->tabText->setText(TAB_BUTTON_NAMES.at(tabIndex));
        ui->tabText->setText(QObject::tr(TAB_BUTTON_NAMES.at(tabIndex).toUtf8()));
        writeInterface(SHOW_FILE);
        break;
    }

    case 4:
    {
        auto window = new SubWindowDiagnose(this);
        subWindow = window;
        //ui->tabText->setText(TAB_BUTTON_NAMES.at(tabIndex));
        ui->tabText->setText(QObject::tr(TAB_BUTTON_NAMES.at(tabIndex).toUtf8()));
        writeInterface(SHOW_DIAG);
        break;
    }

    default:
        break;
    }

    if(nullptr != subWindow)
        setSubWindow(subWindow);
}

void MainWindow::onMoveAxis(int axisNum, int direction, int pressType, double distance)
{
    // debug_printf("moveAxis, axis=%d, dir=%d, type=%d, distance=%f",axisNum,direction,pressType,distance);
    auto manualMove = new MANUALCOMM;

    manualMove->type = 0;
    manualMove->type |= axisNum << 8;

    unsigned short moveType = 0;

    if(QPushButtonLongPress::PressShort == pressType)  // 短按
    {
        moveType = (SubWindowTeachTable::MovePlus == direction ? Manual_P_Step : Manual_M_Step);
    }
    else if(QPushButtonLongPress::PressLongBegin == pressType)   // 长按开始
    {
        moveType = (SubWindowTeachTable::MovePlus == direction ? Manual_P_Continue : Manual_M_Continue);
    }
    else   // 长按结束
    {
        moveType = Manual_Stop;
    }

    manualMove->type |= moveType;
    manualMove->pos = static_cast<float>(distance);

    auto queryItem = new ModbusQueryItemType;
    queryItem->queryAction = Action_WriteManualMove;
    queryItem->mixData.otherData = manualMove;
    emit sendModbusQuery(queryItem);
}

void MainWindow::onNotifyOffline()
{
    ui->alarmMessage->setBlinkStyle(2);
    ui->alarmMessage->setText("通信中断，请重启软件");
}

void MainWindow::setSubWindow(QWidget* subWindow)
{
    if(nullptr != lastSubWindow)
    {
        ui->layout_SubWindow->removeWidget(lastSubWindow);
        lastSubWindow->close();
        lastSubWindow->deleteLater();
    }

    ui->layout_SubWindow->addWidget(subWindow);
    lastSubWindow = subWindow;
}

void MainWindow::writeInterface(int i)
{
    auto queryItem = new ModbusQueryItemType;
    queryItem->queryAction = Action_WriteInterface;
    queryItem->mixData.u16 = static_cast<quint16>(i);
    emit sendModbusQuery(queryItem);
}

void MainWindow::readWorkfileName()
{
    auto queryItem = new ModbusQueryItemType;
    queryItem->queryAction = Action_ReadWorkfileName;
    queryItem->mixData.otherData = new char[24];
    emit sendModbusQuery(queryItem);
}

void MainWindow::onUpdateRealtimeInfo()
{
    static quint16 lastAlarmNumber = 0xffff;
    static quint32 lastPointIndex = 0xffff;
    static quint32 lastTotalPoint = 0xffff;

    if(GlobalData::realTimeInfo.iAlarmSta!=NORMAL)
    {//系统故障
        if(lastAlarmNumber != GlobalData::realTimeInfo.iAlarmSta)
        {
            //qDebug("alarm=%d",GlobalData::realTimeInfo.iAlarmSta);
            auto i = static_cast<int>(GlobalData::realTimeInfo.iAlarmSta);
            ui->alarmMessage->setText(Adapters::getAlarmMessage(i));
            ui->alarmMessage->setBlinkStyle(Adapters::getAlarmLevel(i));

            lastAlarmNumber = GlobalData::realTimeInfo.iAlarmSta;
        }
    }
    else
    {
        ui->alarmMessage->setText("系统正常");
        ui->alarmMessage->setBlinkStyle(Adapters::getAlarmLevel(NORMAL));
    }

    // 当前孔数
    if(lastPointIndex != GlobalData::realTimeInfo.iCNum)
    {
        auto i = static_cast<int>(GlobalData::realTimeInfo.iCNum);

        emit pointIndexChanged(i);
        lastPointIndex = GlobalData::realTimeInfo.iCNum;
    }

    // 总孔数
    if(lastTotalPoint != GlobalData::realTimeInfo.iMNum)
    {
        auto i = static_cast<int>(GlobalData::realTimeInfo.iMNum);

        emit totalPointChanged(i);
        lastTotalPoint = GlobalData::realTimeInfo.iMNum;
    }
}

void MainWindow::onButtonClicked_ResetAlarm()
{
    auto queryItem = new ModbusQueryItemType;
    queryItem->queryAction = Action_WriteResetAlarm;
    queryItem->mixData.u16 = ALMCLEAR_KEY;
    emit sendModbusQuery(queryItem);
}

void MainWindow::_onClickedBottomButton(int btn_id)
{
    QWidget* subWindow = nullptr;

    switch(btn_id)
    {
    case Definitions::BTN_SYS_TRACEPATH://轨迹
    {
        auto window = new SubWindowTrail(this);
        subWindow = window;
        break;
    }
    case Definitions::BTN_TEACH_PATTERN://花样
    {
        auto window = new SubWindowPatterns(this);
        subWindow = window;
        break;
    }
<<<<<<< HEAD

    case Definitions::BTN_DIAGNOSE_SCREENCONFIG://本地配置
    {
        auto window = new SubWindowLocalConfig(this);
        subWindow = window;
        break;
    }

=======
>>>>>>> cj
    default:
        break;
    }

    if(nullptr != subWindow)
        setSubWindow(subWindow);
}

void MainWindow::show()
{
    onTabIndexChanged(0); // page one

    onUpdateRealtimeInfo(); // refresh now!

    // load workfile
    //    if(Workfile::getInstance()->isAlreadyReadAll() == false){
    //        auto workfileDialog=new QDialogLoadingWorkfile(this);
    //        workfileDialog->setAttribute(Qt::WA_DeleteOnClose);
    //        workfileDialog->readWrite(true,-1,0);
    //    }

    // 这个connect不放在构造函数内，因为有可能onNotifyOffline()比show()更早执行，导致Segmentation fault
    connect(GlobalData::modbusQueue, SIGNAL(notifyOffline()),
            this, SLOT(onNotifyOffline()));

    readWorkfileName();

    workerThread->start();

    QWidget::show();
}


void MainWindow::onSendModbusQuery(MainWindow::ModbusQueryItemType* queryItem, int workerQueryItemIndex)
{
    bool isQueryValid = true;

    auto element = new ModbusQueue::element_t;
    queryItem->workerQueryItemIndex = workerQueryItemIndex;

    switch(queryItem->queryAction)
    {
    case Action_ReadStatus:
        element->data = &GlobalData::realTimeInfo;
        element->len = sizeof(GlobalData::realTimeInfo);
        element->operation = ModbusQueue::OP_READ_DATA;
        element->startAddress = ModbusAddress::ControllerRealTimeInfo;
        break;

    case Action_WriteManualMove:
        element->data = queryItem->mixData.otherData;
        element->len = sizeof(MANUALCOMM);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::ManulMove;
        break;

    case Action_WriteResetAlarm:
        element->data = &queryItem->mixData.u16;
        element->len = sizeof(unsigned short);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::WorkCommand;
        break;

    case Action_WriteInterface:
        element->data = &queryItem->mixData.u16;
        element->len = sizeof(unsigned short);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::Interface;
        break;

    case Action_ReadWorkfileName:
        element->data = queryItem->mixData.otherData;
        element->len = sizeof(char) * 24;
        element->operation = ModbusQueue::OP_READ_DATA;
        element->startAddress = ModbusAddress::CurrentWorkFilename;
        break;

    case Action_WriteHeartBeat:
        element->data = &heartBeatCounter;
        element->len = sizeof(heartBeatCounter);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::HeartBeat;
        break;

    default:
        isQueryValid = false;
        break;
    }

    if(true == isQueryValid)
    {
        element->pointerObject = queryItem;
        element->callback = std::tr1::bind(&MainWindow::_modbusQueryCallback, this, std::tr1::placeholders::_1,
                                           std::tr1::placeholders::_2);
        GlobalData::modbusQueue->sendQuery(element); // send it!

        ++modbusPendingCount;
    }
    else
    {
        Utils::delete_pointer(element);
        Utils::delete_pointer(queryItem);
    }
}

void MainWindow::onModbusQueryCallbackEnd(bool isOk, void* flag)
{
    bool isNeedDelete = true;

    auto element = reinterpret_cast<ModbusQueue::element_t*>(flag);
    auto queryItem = reinterpret_cast<ModbusQueryItemType*>(element->pointerObject);

    if(isOk)
    {
        retrytime=0;
        switch(queryItem->queryAction)
        {
        case Action_ReadStatus:
            emit _signal_notifyWorkerQueryDone(queryItem->workerQueryItemIndex);
            emit _updateRealtimeInfo();
            break;

        case Action_ReadWorkfileName:
            GlobalData::workfileName = Utils::gbkCharToQString(reinterpret_cast<char*>(queryItem->mixData.otherData));
            break;

        case Action_WriteHeartBeat:
            ++heartBeatCounter;
            emit _signal_notifyWorkerQueryDone(queryItem->workerQueryItemIndex);
            break;

        default:
            break;
        }
    }
    else
    {
        if(true == Utils::dialogIsModbusRetry(this, GlobalData::modbusQueue))
        {
            GlobalData::modbusQueue->sendQuery(element, true, false);
            GlobalData::modbusQueue->queryResume();
            isNeedDelete = false;
        }
        else
        {
            GlobalData::modbusQueue->queryStopThenOffline();
        }
    }

    if(true == isNeedDelete)
    {
        // free special memory
        switch(queryItem->queryAction)
        {
        case Action_WriteManualMove:
        {
            auto manulMove = reinterpret_cast<MANUALCOMM*>(element->data);
            Utils::delete_pointer(manulMove);
            break;
        }

        case Action_ReadWorkfileName:
        {
            auto filenameBuffer = reinterpret_cast<char*>(element->data);
            Utils::delete_array(filenameBuffer);
            break;
        }

        default:
            break;
        }

        // free normal memory
        Utils::delete_pointer(queryItem);
        Utils::delete_pointer(element);

        --modbusPendingCount;
    }
}

QThreadMainWindow::QThreadMainWindow(QObject* parent): QThread(parent),
    quitFlag(false)
{
    ConstantlyQueryItemType item;

    item.queryType = MainWindow::Action_ReadStatus;
    item.elapsedTimer.start();
    item.interval = 100;
    item.pendingMutex = new QMutex;
    allQueries.append(item);

    item.queryType = MainWindow::Action_WriteHeartBeat;
    item.elapsedTimer.start();
    item.interval = 1000;
    item.pendingMutex = new QMutex;
    allQueries.append(item);
}

QThreadMainWindow::~QThreadMainWindow()
{
    //debug_printf("~QThreadMainWindow();");

    foreach(const ConstantlyQueryItemType& item, allQueries)
    {
        delete item.pendingMutex;
    }
}

void QThreadMainWindow::run()
{
    while(false == quitFlag)
    {
        for(auto i = 0; i < allQueries.size(); ++i)
        {
            ConstantlyQueryItemType& item = allQueries[i];

            if(item.elapsedTimer.elapsed() >= item.interval && item.pendingMutex->tryLock())
            {
                auto queryItem = new MainWindow::ModbusQueryItemType;
                queryItem->queryAction = item.queryType;
                emit sendModbusQuery(queryItem, i);
                item.elapsedTimer.start();
            }

            Utils::sleep(10);

        }
    }

    //debug_printf("QThreadMainWindow::run() END");
}

void QThreadMainWindow::setQuitFlag(bool quitFlag)
{
    this->quitFlag = quitFlag;
}

void QThreadMainWindow::queryDone(int workerQueryItemIndex)
{
    if(workerQueryItemIndex < 0 || workerQueryItemIndex >= allQueries.size())
        return;

    //debug_printf("unlocking...");
    allQueries.at(workerQueryItemIndex).pendingMutex->unlock();
}
