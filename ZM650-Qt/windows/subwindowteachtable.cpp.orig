/*
 * subwindowteachtable.cpp
 *
 * 教导界面
 *
 * Created on: 2019年 01月 21日 星期一 15:00:16 CST
 * Author: lixingcong
 */
#include "subwindowteachtable.h"
#include "ui_subwindowteachtable.h"
#include "data/globaldata.h"
#include "data/definitions.h"
#include "data/workfile.h"
#include "data/utils.h"
#include "data/utilsforcontroller.h"
#include "Teach.h"
#include "widgets/qpushbuttonlongpress.h"
#include "widgets/qpushbuttonspage.h"
#include "widgets/qitemmodelteach.h"
#include "widgets/qdialogdataform.h"
#include "modbus/modbusqueue.h"
#include "modbus/modbusaddress.h"
#include <Teach.h>
#include "widgets/qdialogloadingworkfile.h"
#include <TestIO.h>
#include <QMessageBox>
#include "data/uistyles.h"


#define PROP_AXISNUM "axisNum"
#define PROP_DIRECTION "direction"

SubWindowTeachTable::SubWindowTeachTable(QWidget* parent) :
    QWidget(parent),
    ui(new Ui::SubWindowTeachTable),
    modbusPendingCount(0)
{
    ui->setupUi(this);

    ui->widgetStatus->init(GlobalData::axisName, GlobalData::totalAxisNum);
    connect(ui->widgetStatus, SIGNAL(updateTeachStep(unsigned int)),
           this, SLOT(_onsendTeachAction(unsigned int)));

    connect(this, SIGNAL(SetTeachStepText()),
           ui->widgetStatus, SLOT(onSetTeachStepText()));
    ;

    auto _totalPoint = static_cast<int>(GlobalData::realTimeInfo.iMNum);
    auto _pointIndex = static_cast<int>(GlobalData::realTimeInfo.iCNum);
<<<<<<< HEAD

    ui->tableViewTeach->init(5, _totalPoint, MAXTEACHNUM, GlobalData::totalAxisNum, GlobalData::axisName, 10);
//    ui->tableViewTeach->verticalHeader()->setDefaultSectionSize(10);//高
//    ui->tableViewTeach->horizontalHeader()->setDefaultSectionSize(15);//宽
=======

    ui->tableViewTeach->init(5, _totalPoint, MAXTEACHNUM, GlobalData::totalAxisNum, GlobalData::axisName, 9);

//   ui->tableViewTeach->verticalHeader()->setDefaultSectionSize(10);//高
//   ui->tableViewTeach->horizontalHeader()->setDefaultSectionSize(15);//宽
>>>>>>> cj
    for(auto i = 0; i < GlobalData::totalAxisNum; ++i)
    {
        auto btn_plus = new QPushButtonLongPress(GlobalData::axisName.at(i) + "+", this);
        auto btn_minus = new QPushButtonLongPress(GlobalData::axisName.at(i) + "-", this);

        //ui->gridLayoutButtons->addWidget(btn_plus, 0, i);
        //ui->gridLayoutButtons->addWidget(btn_minus, 1, i);

        ui->horizontalLayoutButtons->addWidget(btn_plus);
        ui->horizontalLayoutButtons->addWidget(btn_minus);
        //stylesheet
        btn_plus->setStyleSheet(UIStyles::css_teachcolorconf_u0);
        btn_minus->setStyleSheet(UIStyles::css_teachcolorconf_u0);

        // extra info
        btn_plus->setProperty(PROP_AXISNUM, i + 1);
        btn_minus->setProperty(PROP_AXISNUM, i + 1);
        btn_plus->setProperty(PROP_DIRECTION, MovePlus);
        btn_minus->setProperty(PROP_DIRECTION, MoveMinus);

        connect(btn_plus, SIGNAL(keyPress(int)), this, SLOT(_onMoveButtonPress(int)));
        connect(btn_minus, SIGNAL(keyPress(int)), this, SLOT(_onMoveButtonPress(int)));
    }

    // bottom btns
    QList<QPushButtonsPage::item_t> listButtonItems =
    {
        {tr("添加"), Definitions::BTN_TEACH_ADD},
        {tr("修改"), Definitions::BTN_TEACH_MODIFY},
        {tr("删除"), Definitions::BTN_TEACH_DELETE},
        {tr("上孔"), Definitions::BTN_TEACH_PREVHOLE},
        {tr("下孔"), Definitions::BTN_TEACH_NEXTHOLE},
        {tr("定位"), Definitions::BTN_TEACH_LOCATE},
        {tr("插入"), Definitions::BTN_TEACH_INSERT},
        {tr("分孔"), Definitions::BTN_TEACH_DIVIDE},
        {tr("上页"), Definitions::BTN_TEACH_PAGEUP},
        {tr("下页"), Definitions::BTN_TEACH_PAGEDOWN},
        {tr("复制"),  Definitions::BTN_TEACH_COPY},
        {tr("量色"), Definitions::BTN_TEACH_COLOR_MULTIPLE},
        {tr("量删"), Definitions::BTN_TEACH_DELETE_MULTIPLE},
        {tr("平移"), Definitions::BTN_TEACH_SHIFT},
        {tr("花样"), Definitions::BTN_TEACH_PATTERN}
    };

    GlobalData::pushButtonPage->init(listButtonItems);
    connect(GlobalData::pushButtonPage, SIGNAL(buttonClicked(int)),
            this, SLOT(_onClickedBottomButton(int)));

    // table
    connect(this, SIGNAL(TableChangePageNum(int)),
            ui->tableViewTeach, SLOT(onPageChanged(int)));
    connect(ui->tableViewTeach, SIGNAL(pointDataChangedByUserInput(int)),
            this, SLOT(onPointDataChangedByUserInput(int)));
    connect(ui->tableViewTeach, SIGNAL(reloadPageTeachData()),
            this, SLOT(onReloadPageTeachData()));
    connect(ui->tableViewTeach, SIGNAL(notifyTowriteCylinder(int, int)),
            this, SLOT(_onNotifyTowriteCylinder(int, int)));
    connect(ui->tableViewTeach, SIGNAL(pmoveToPoint(int)),
            this, SLOT(_onPmoveToPoint(int)));

    // modbus callback
    connect(this, SIGNAL(_signal_modbusQueryCallback(bool, void*)),
            this, SLOT(onModbusQueryCallbackEnd(bool, void*)));
    connect(this, SIGNAL(sendModbusQuery(Definitions::ModbusQueryItem*)),
            this, SLOT(onSendModbusQuery(Definitions::ModbusQueryItem*)));

    // global signals
    connect(GlobalData::getInstance(), SIGNAL(updateRealtimeInfo()),
            this, SLOT(onUpdateRealtimeInfo()));

    onUpdateRealtimeInfo(); // refresh now!
    onTotalPointChanged(_totalPoint);
    onPointIndexChanged(_pointIndex);
}

SubWindowTeachTable::~SubWindowTeachTable()
{
    Utils::waitForPendingModbus(&modbusPendingCount);
    delete ui;
}

void SubWindowTeachTable::onUpdateRealtimeInfo()
{
    static quint32 lastTeachCounter = 0xffffffff;
    static quint8 lastWorkStatus = 0xff;
    static quint16 lastHandRange = 0xffff;

    ui->widgetStatus->onUpdateAxisPosition();

    if(lastTeachCounter != GlobalData::realTimeInfo.iTeachAcc)
    {
        onReloadPageTeachData();
        lastTeachCounter = GlobalData::realTimeInfo.iTeachAcc;
    }

    if(lastWorkStatus != GlobalData::realTimeInfo.iWSta)
    {
        if(Stop != lastWorkStatus && Stop == GlobalData::realTimeInfo.iWSta)
            emit workstausChangedToStop();

        lastWorkStatus = GlobalData::realTimeInfo.iWSta;
    }

    //add by yzg 190526
    if(lastHandRange != GlobalData::realTimeInfo.iHandRange)
    {
        emit SetTeachStepText();
        lastHandRange=GlobalData::realTimeInfo.iHandRange;
    }
}


void SubWindowTeachTable::onPointIndexChanged(int pointIndex)
{
    ui->widgetStatus->onUpdateCurrentPointIndex(pointIndex);

    if(Run != GlobalData::realTimeInfo.iWSta)
        ui->tableViewTeach->onNewPointIndexChanged(pointIndex);
}

void SubWindowTeachTable::onTotalPointChanged(int totalPoint)
{
    ui->widgetStatus->onUpdateTotalPoint(totalPoint);

    ui->tableViewTeach->onTotalPointNumChanged(totalPoint);
}

void SubWindowTeachTable::onPointDataChangedByUserInput(int pointIndex)
{
    auto teachSend = new TEACH_SEND;
    void* p = &teachSend->SendData.Teach_Data;
    memcpy(p, Workfile::getInstance()->getTeachData() + pointIndex, sizeof(TEACH_DATA)); // 复制一个点的数据
    teachSend->Num = pointIndex;
    teachSend->Type = TEACH_MODIFY;
    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::onDialogAcceptedSplit()
{
    auto teachSend = new TEACH_SEND;
    teachSend->Type = TEACH_SPLIT;

    Utils::copyValues(GlobalData::realTimeInfo.iProg, teachSend->SendData.N_Apart.IoSta, 6);
    teachSend->SendData.N_Apart.iSplit_N = teachDialogVars.divides;
    teachSend->SendData.N_Apart.iColor = GlobalData::realTimeInfo.iColorSta;

    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::onDialogAcceptedCopy()
{
    auto teachSend = new TEACH_SEND;
    teachSend->Type = TEACH_COPY;
    teachSend->SendData.N_COPY.iStart_N = teachDialogVars.startIndex;
    teachSend->SendData.N_COPY.iEnd_N = teachDialogVars.endIndex;
    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::onDialogAcceptedLocate()
{
    auto teachSend = new TEACH_SEND;
    teachSend->Type = FIXED_HOLE;
    teachSend->Num = teachDialogVars.startIndex;
    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::onDialogAcceptedDeleteMultiple()
{
    auto teachSend = new TEACH_SEND;
    teachSend->SendData.N_Color.iStart_N = teachDialogVars.startIndex;
    teachSend->SendData.N_Color.iEnd_N = teachDialogVars.endIndex;
    teachSend->Type = TEACH_MUL_DEL;
    teachSend->Num = teachDialogVars.startIndex;
    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::onDialogAcceptedMultiColor()
{
    auto teachSend = new TEACH_SEND;
    teachSend->Type = TEACH_MUL_COLOR;
    teachSend->SendData.N_Color.iStart_N = teachDialogVars.startIndex;
    teachSend->SendData.N_Color.iEnd_N = teachDialogVars.endIndex;
    teachSend->SendData.N_Color.iColor = teachDialogVars.color;
    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::onDialogAcceptedShift()
{
    auto teachSend = new TEACH_SEND;
    memset(teachSend, 0, sizeof(TEACH_SEND));

    teachSend->Type = TEACH_SHIFT;
    teachSend->SendData.N_Offset.iStart_N=teachDialogVars.startIndex;
    teachSend->SendData.N_Offset.iEnd_N=teachDialogVars.endIndex;

    Utils::copyValues(GlobalData::realTimeInfo.fPos,teachSend->SendData.N_Offset.fAxisShift,6);
    teachSend->SendData.N_Offset.fCoord[1]=GlobalData::realTimeInfo.iMovesta * ATPARA.fLength_Two;

    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::_onPmoveToPoint(int pointIndex)
{
    auto teachSend = new TEACH_SEND;
    teachSend->Type = FIXED_HOLE;
    teachSend->Num = pointIndex;
    sendTEACHSEND(teachSend);
}

void SubWindowTeachTable::_onMoveButtonPress(int pressType)
{
    auto axis = qvariant_cast<int>(sender()->property(PROP_AXISNUM));
    auto direction = qvariant_cast<int>(sender()->property(PROP_DIRECTION));

    emit moveAxis(axis, direction, pressType, ui->widgetStatus->getMoveStep());
}

void SubWindowTeachTable::_onClickedBottomButton(int btn_id)
{
    memset(&teachDialogVars, 0, sizeof(teachDialogVars));

    switch(btn_id)
    {
    case Definitions::BTN_TEACH_ADD: // 添加
    case Definitions::BTN_TEACH_INSERT: // 插入
    {
        auto teachSend = new TEACH_SEND;
        memset(teachSend, 0, sizeof(TEACH_SEND));

        Utils::copyValues(GlobalData::realTimeInfo.iProg, teachSend->SendData.Teach_Data.iOut, 6);
        Utils::copyValues(GlobalData::realTimeInfo.fPos, teachSend->SendData.Teach_Data.fMove_pos, GlobalData::totalAxisNum);

        teachSend->SendData.Teach_Data.icolor = GlobalData::realTimeInfo.iColorSta;

        if(btn_id == Definitions::BTN_TEACH_ADD)
        {
            teachSend->Type = TEACH_ADD;
            teachSend->Num = ui->tableViewTeach->getTotalPointNum();
        }
        else
        {
            teachSend->Type = TEACH_INSERT;
            teachSend->Num = ui->tableViewTeach->getPointIndex();
        }

        sendTEACHSEND(teachSend);
        break;
    }

    case Definitions::BTN_TEACH_MODIFY: // 修改
    {
//        if(QMessageBox::Yes != QMessageBox::question(this, "?", QString::fromUtf8(tr("修改教导点%1吗？")).arg(GlobalData::realTimeInfo.iCNum),
//                QMessageBox::Yes | QMessageBox::No))
        if(QMessageBox::Yes != QMessageBox::question(this, "?", tr("修改教导点%1吗？").arg(GlobalData::realTimeInfo.iCNum),
                QMessageBox::Yes | QMessageBox::No))
            break;

        auto teachSend = new TEACH_SEND;
        memset(teachSend, 0, sizeof(TEACH_SEND));

        teachSend->Type = TEACH_MODIFY;
        teachSend->Num = GlobalData::realTimeInfo.iCNum; // 实际孔
        Utils::copyValues(GlobalData::realTimeInfo.iProg, teachSend->SendData.Teach_Data.iOut, 6);
        Utils::copyValues(GlobalData::realTimeInfo.fPos, teachSend->SendData.Teach_Data.fMove_pos, GlobalData::totalAxisNum);

        teachSend->SendData.Teach_Data.icolor = GlobalData::realTimeInfo.iColorSta;

        sendTEACHSEND(teachSend);
        break;
    }

    case Definitions::BTN_TEACH_DELETE: // 删除
    {
//        if(QMessageBox::Yes != QMessageBox::question(this, "?", QString::fromUtf8(tr("删除教导点%1吗？")).arg(ui->tableViewTeach->getPointIndex()),
//                QMessageBox::Yes | QMessageBox::No))
        if(QMessageBox::Yes != QMessageBox::question(this, "?", tr("删除教导点%1吗？").arg(ui->tableViewTeach->getPointIndex()),
                QMessageBox::Yes | QMessageBox::No))
            break;

        auto teachSend = new TEACH_SEND;
        teachSend->Num = ui->tableViewTeach->getPointIndex(); // 选中那个列
        teachSend->Type = TEACH_DELETE;
        sendTEACHSEND(teachSend);
        break;
    }

    case Definitions::BTN_TEACH_DELETE_MULTIPLE: // 量删
    {
        teachDialogVars.startIndex = ui->tableViewTeach->getPointIndex();
        teachDialogVars.endIndex = ui->tableViewTeach->getTotalPointNum() - 1;

        QList<QDialogDataForm::item_t> items =
        {
            //{QString::fromUtf8(tr("从这个点")), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 0, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            //{QString::fromUtf8(tr("到这个点")), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 0, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr}
            {tr("从这个点"), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 0, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("到这个点"), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 0, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr}

        };

        auto w = new QDialogDataForm(this, Qt::FramelessWindowHint);
        connect(w, SIGNAL(accepted()), this, SLOT(onDialogAcceptedDeleteMultiple()));
        //w->showDialog(QString::fromUtf8(tr("批量删除教导点")), items);
        w->showDialog(tr("批量删除教导点"), items);

        break;
    }

    case Definitions::BTN_TEACH_PREVHOLE: // 上孔
    case Definitions::BTN_TEACH_NEXTHOLE: // 下孔
    {
        if(true == Utils::checkWorkstatusIfStop())
        {
            auto teachSend = new TEACH_SEND;
            teachSend->Type = (Definitions::BTN_TEACH_PREVHOLE == btn_id ? LAST_HOLE : NEXT_HOLE);
            sendTEACHSEND(teachSend);
        }

        break;
    }

    case Definitions::BTN_TEACH_LOCATE: // 定位
    {
        if(true == Utils::checkWorkstatusIfStop())
        {
            teachDialogVars.startIndex = ui->tableViewTeach->getPointIndex();
            QList<QDialogDataForm::item_t> items =
            {
                //{QString::fromUtf8(tr("定位")), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 0, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
                {tr("定位"), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 0, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},

            };

            auto w = new QDialogDataForm(this, Qt::FramelessWindowHint);
            connect(w, SIGNAL(accepted()), this, SLOT(onDialogAcceptedLocate()));
            //w->showDialog(QString::fromUtf8(tr("定位到某一个孔")), items);
            w->showDialog(tr("定位到某一个孔"), items);

        }

        break;
    }

    case Definitions::BTN_TEACH_DIVIDE: // 分孔
    {
        teachDialogVars.startIndex = ui->tableViewTeach->getPointIndex();

        if(2 > teachDialogVars.startIndex) // 分孔是当前孔与上一个孔进行分孔，pointIndex小于2则不分孔
            return;

        teachDialogVars.divides = 1;

        QList<QDialogDataForm::item_t> items =
        {
            //{QString::fromUtf8(tr("分孔数")), Adapters::TYPE_S32, &teachDialogVars.divides, false, 2, MAXTEACHNUM - 1, nullptr},
            {tr("分孔数"), Adapters::TYPE_S32, &teachDialogVars.divides, false, 2, MAXTEACHNUM - 1, nullptr},

        };

        auto w = new QDialogDataForm(this, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
        connect(w, SIGNAL(accepted()), this, SLOT(onDialogAcceptedSplit()));
        //w->showDialog(QString::fromUtf8(tr("分孔：当前孔与上一个孔之间，要分多少孔")), items, true);
        w->showDialog(tr("分孔：当前孔与上一个孔之间，要分多少孔"), items, true);

        break;
    }

    case Definitions::BTN_TEACH_COPY: // 复制
    {
        teachDialogVars.startIndex = ui->tableViewTeach->getPointIndex();

        if(0 >= teachDialogVars.startIndex)
            teachDialogVars.startIndex = 1;

        teachDialogVars.endIndex = ui->tableViewTeach->getTotalPointNum() - 1;

        QList<QDialogDataForm::item_t> items =
        {
            //{QString::fromUtf8(tr("开始孔")), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            //{QString::fromUtf8(tr("结束孔")), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("开始孔"), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("结束孔"), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},

        };

        auto w = new QDialogDataForm(this, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
        connect(w, SIGNAL(accepted()), this, SLOT(onDialogAcceptedCopy()));
        //w->showDialog(QString::fromUtf8(tr("复制：从开始孔")), items, true);
        w->showDialog(tr("复制：从开始孔"), items, true);
        break;
    }

    case Definitions::BTN_TEACH_PAGEUP: // 上页
    {
        auto pageNum = ui->tableViewTeach->getCurrentPageNum();

        if(pageNum <= 0)
            return;

        emit TableChangePageNum(--pageNum);
        break;
    }

    case Definitions::BTN_TEACH_PAGEDOWN: // 下页
    {
        auto pageNum = ui->tableViewTeach->getCurrentPageNum();

        if(pageNum >= ui->tableViewTeach->getMaxPage())
            return;

        emit TableChangePageNum(++pageNum);
        break;
    }

    case Definitions::BTN_TEACH_COLOR_MULTIPLE: // 量色
    {
        teachDialogVars.startIndex = ui->tableViewTeach->getPointIndex();
        teachDialogVars.endIndex = ui->tableViewTeach->getTotalPointNum() - 1;
        teachDialogVars.color=0;

        if(0>=teachDialogVars.startIndex)
            break;

        auto colorList=QStringList({tr("颜色0"), tr("颜色1")});

        if(SYS_ZM.bThreeColor)
            colorList<<tr("颜色2");

        QList<QDialogDataForm::item_t> items =
        {
//            {QString::fromUtf8(tr("颜色")), Adapters::TYPE_StringList, &teachDialogVars.color, false, 0, 2, &colorList},
//            {QString::fromUtf8(tr("开始孔")), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
//            {QString::fromUtf8(tr("结束孔")), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("颜色"), Adapters::TYPE_StringList, &teachDialogVars.color, false, 0, 2, &colorList},
            {tr("开始孔"), Adapters::TYPE_S32, &teachDialogVars.startIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("结束孔"), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},

        };

        auto w = new QDialogDataForm(this, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
        connect(w, SIGNAL(accepted()), this, SLOT(onDialogAcceptedMultiColor()));
        //w->showDialog(QString::fromUtf8(tr("批量修改颜色")), items, true);
        w->showDialog(tr("批量修改颜色"), items, true);

        break;
    }

    case Definitions::BTN_TEACH_SHIFT: // 平移
    {
        teachDialogVars.startIndex = GlobalData::realTimeInfo.iCNum;
        teachDialogVars.endIndex = ui->tableViewTeach->getTotalPointNum() - 1;


        QList<QDialogDataForm::item_t> items =
        {
//            {QString::fromUtf8(tr("开始孔")), Adapters::TYPE_S32, &teachDialogVars.startIndex, true, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
//            {QString::fromUtf8(tr("结束孔")), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("开始孔"), Adapters::TYPE_S32, &teachDialogVars.startIndex, true, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},
            {tr("结束孔"), Adapters::TYPE_S32, &teachDialogVars.endIndex, false, 1, ui->tableViewTeach->getTotalPointNum() - 1.0, nullptr},

        };

        auto w = new QDialogDataForm(this, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
        connect(w, SIGNAL(accepted()), this, SLOT(onDialogAcceptedShift()));
        //w->showDialog(QString::fromUtf8(tr("批量偏移加工点")), items, true);
        w->showDialog(tr("批量偏移加工点"), items, true);

        break;
    }

    default:
        break;
    }
}

void SubWindowTeachTable::_onNotifyTowriteCylinder(int cylinderIndex, int status)
{
    auto queryItem = new Definitions::ModbusQueryItem;
    queryItem->queryAction = Action_WriteCylinder;
    queryItem->mixData.u32  = static_cast<unsigned short>(cylinderIndex);
    queryItem->mixData.u32 |= static_cast<unsigned short>(status) << 16;
    emit sendModbusQuery(queryItem);
}

void SubWindowTeachTable::sendTEACHSEND(TEACH_SEND* teachSend)
{
    auto queryItem = new Definitions::ModbusQueryItem;
    queryItem->queryAction = Action_TeachSend;
    queryItem->mixData.otherData = teachSend;
    emit sendModbusQuery(queryItem);
}

//add by yzg 190529
void SubWindowTeachTable::_onsendTeachAction(unsigned int data)
{
    auto queryItem = new Definitions::ModbusQueryItem;
    queryItem->queryAction = Action_TeachStep;
    queryItem->mixData.u16 = static_cast<unsigned short>(data);
    emit sendModbusQuery(queryItem);
}

void SubWindowTeachTable::onReloadPageTeachData()
{
    int pageNum = ui->tableViewTeach->getCurrentPageNum();
    int startIndex = 0;
    int pointCount = 0;

    ui->tableViewTeach->getStartIndexFromPage(pageNum, &startIndex, &pointCount);

    // debug_printf("onReloadPageTeachData: startIndex=%d, pointCount=%d",startIndex,pointCount);

    auto d = new QDialogLoadingWorkfile(this);
    d->setAttribute(Qt::WA_DeleteOnClose);
    connect(d, SIGNAL(accepted()),
            ui->tableViewTeach, SLOT(reloadItemModel())); // 自动刷新教导数据
    d->readWrite(true, startIndex, pointCount,true);
}

void SubWindowTeachTable::onSendModbusQuery(Definitions::ModbusQueryItem* queryItem)
{
    bool isQueryValid = true;
    auto element = new ModbusQueue::element_t;

    switch(queryItem->queryAction)
    {
    case Action_TeachSend:
        element->data = queryItem->mixData.otherData;
        element->len = sizeof(TEACH_SEND);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::TeachWorkfileHead;
        break;

    case Action_WriteCylinder:
    {
        auto cylinderIndex = queryItem->mixData.u32 & 0xffff;
        auto realIO = Adapters::getRealIOFromFunctionCode(OUT_PROG1 + cylinderIndex, false);

        queryItem->mixData.u16 = static_cast<unsigned short>(queryItem->mixData.u32 >> 16);

        element->data = &queryItem->mixData.u16;
        element->len = sizeof(queryItem->mixData.u16);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::IOStatus_Out + realIO;
        break;
    }

    //教导步长 add  by yzg 190529
    case Action_TeachStep:
        element->data = &queryItem->mixData.u16;
        element->len = sizeof(queryItem->mixData.u16);
        element->operation = ModbusQueue::OP_WRITE_DATA;
        element->startAddress = ModbusAddress::g_WheelGear;
        break;

    default:
        isQueryValid = false;
        break;
    }

    if(true == isQueryValid)
    {
        element->pointerObject = queryItem;
        element->callback = std::tr1::bind(&SubWindowTeachTable::_modbusQueryCallback, this, std::tr1::placeholders::_1,
                                           std::tr1::placeholders::_2);
        GlobalData::modbusQueue->sendQuery(element); // send it!
        ++modbusPendingCount;
    }
    else
    {
        Utils::delete_pointer(element);
        Utils::delete_pointer(queryItem);
    }
}

void SubWindowTeachTable::onModbusQueryCallbackEnd(bool isOk, void* flag)
{
    bool isNeedDelete = true;

    auto element = reinterpret_cast<ModbusQueue::element_t*>(flag);
    auto queryItem = reinterpret_cast<Definitions::ModbusQueryItem*>(element->pointerObject);

    if(isOk)
    {
        retrytime=0;
        switch(queryItem->queryAction)
        {
        default:
            break;
        }
    }
    else
    {
        if(true == Utils::dialogIsModbusRetry(this, GlobalData::modbusQueue))
        {
            GlobalData::modbusQueue->sendQuery(element, true, false);
            GlobalData::modbusQueue->queryResume();
            isNeedDelete = false;
        }
        else
        {
            GlobalData::modbusQueue->queryStopThenOffline();
        }
    }

    if(true == isNeedDelete)
    {
        // free special memory
        switch(queryItem->queryAction)
        {
        case Action_TeachSend:
        {
            auto teachSend = reinterpret_cast<TEACH_SEND*>(queryItem->mixData.otherData);
            Utils::delete_pointer(teachSend);
            break;
        }

        default:
            break;
        }

        // free general memory
        Utils::delete_pointer(queryItem);
        Utils::delete_pointer(element);

        --modbusPendingCount;
    }
}
